{"version":3,"sources":["../src/index.ts","../src/utils.ts","../src/methods/autobind.ts","../src/methods/decorate.ts","../src/methods/time.ts","../src/prop/configurable.ts","../src/prop/enumerable.ts","../src/prop/extendDescriptor.ts","../src/prop/lazyinit.ts"],"sourcesContent":["export { default as autobind } from './methods/autobind'\r\nexport { default as decorate } from './methods/decorate'\r\nexport { default as time } from './methods/time'\r\n\r\nexport { default as configurable } from './prop/configurable'\r\nexport { default as enumerable } from './prop/enumerable'\r\nexport { default as extendDescriptor } from './prop/extendDescriptor'\r\nexport { default as nonconfigurable } from './prop/lazyinit'\r\nexport { default as nonenumerable } from './prop/lazyinit'\r\nexport { default as readonly } from './prop/lazyinit'","const { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols } = Object\r\n\r\nfunction isDescriptor(desc: Record<PropertyKey, any>): boolean {\r\n  if (!desc || !desc.hasOwnProperty) {\r\n    return false\r\n  }\r\n\r\n  const keys = ['value', 'initializer', 'get', 'set']\r\n\r\n  for (let i = 0, l = keys.length; i < l; i++) {\r\n    if (desc.hasOwnProperty(keys[i])) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nexport function decorate(handleDescriptor: Function, entryArgs: any[]) {\r\n  if (isDescriptor(entryArgs[entryArgs.length - 1])) {\r\n    return handleDescriptor(...entryArgs, [])\r\n  } else {\r\n    return function () {\r\n      return handleDescriptor(...Array.prototype.slice.call(arguments), entryArgs)\r\n    };\r\n  }\r\n}\r\n\r\nexport function createDefaultSetter(key: string) {\r\n  return function set(newValue) {\r\n    defineProperty(this, key, {\r\n      configurable: true,\r\n      writable: true,\r\n      // IS enumerable when reassigned by the outside word\r\n      enumerable: true,\r\n      value: newValue\r\n    })\r\n\r\n    return newValue\r\n  }\r\n}\r\n\r\ninterface BindThis<T extends (...args: any[]) => any, K = any> {\r\n  (this: K, ...args: Parameters<T>): ReturnType<T>;\r\n}\r\n\r\nexport function bind<T extends (...args: any[]) => any, K = any>(fn: T, context: K): BindThis<T, K> {\r\n  if (fn.bind) {\r\n    return fn.bind(context)\r\n  } else {\r\n    return function __autobind__() {\r\n      return fn.apply(context, arguments)\r\n    }\r\n  }\r\n}\r\n\r\nexport const getOwnKeys = getOwnPropertySymbols\r\n    ? function (object) {\r\n        return getOwnPropertyNames(object)\r\n          .concat(getOwnPropertySymbols(object) as any)\r\n      }\r\n    : getOwnPropertyNames\r\n\r\nexport function getOwnPropertyDescriptors(obj: Record<PropertyKey, any>) {\r\n  const descs = {}\r\n\r\n  getOwnKeys(obj).forEach(\r\n    key => (descs[key] = getOwnPropertyDescriptor(obj, key))\r\n  )\r\n\r\n  return descs\r\n}","import { createDefaultSetter, getOwnKeys, getOwnPropertyDescriptors, bind } from '../utils'\r\nconst { defineProperty, getPrototypeOf } = Object\r\n\r\nlet mapStore\r\n\r\n// get bound cache\r\nfunction getBoundSuper(obj, fn) {\r\n  if (typeof WeakMap === 'undefined') {\r\n    throw new Error(\r\n      `Using @autobind on ${fn.name}() requires WeakMap support due to its use of super.${fn.name}()`,\r\n    )\r\n  }\r\n\r\n  if (!mapStore) mapStore = new WeakMap()\r\n\r\n  if (mapStore.has(obj) === false) mapStore.set(obj, new WeakMap())\r\n\r\n  const superStore = mapStore.get(obj)\r\n\r\n  if (superStore.has(fn) === false) superStore.set(fn, bind(fn, obj))\r\n\r\n  return superStore.get(fn)\r\n}\r\n\r\nfunction autobindClass(klass) {\r\n  const descs = getOwnPropertyDescriptors(klass.prototype)\r\n  const keys = getOwnKeys(descs)\r\n\r\n  for (let i = 0, l = keys.length; i < l; i++) {\r\n    const key = keys[i]\r\n    const desc = descs[key]\r\n\r\n    if (typeof desc.value !== 'function' || key === 'constructor') continue\r\n\r\n    defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc))\r\n  }\r\n}\r\n\r\n// autobind method\r\nfunction autobindMethod(target, key, { value: fn, configurable, enumerable }) {\r\n  if (typeof fn !== 'function')\r\n    throw new SyntaxError(`@autobind can only be used on functions, not: ${fn}`)\r\n\r\n  // get root prototype constructor\r\n  const { constructor } = target\r\n\r\n  return {\r\n    configurable,\r\n    enumerable,\r\n    get() {\r\n      // Someone accesses the property directly on the prototype on which it is\r\n      // actually defined on\r\n      if (this === target) return fn\r\n\r\n      // Someone accesses the property directly on a prototype but it was found\r\n      // up the chain, not defined directly on it\r\n      if (this.constructor !== constructor && getPrototypeOf(this).constructor === constructor) return fn\r\n\r\n      // Autobound method calling super.sameMethod() which is also autobound and so on.\r\n      // method is on prototype, should set autobind on super\r\n      if (this.constructor !== constructor && key in this.constructor.prototype) return getBoundSuper(this, fn)\r\n\r\n      const boundFn = bind(fn, this)\r\n\r\n      defineProperty(this, key, {\r\n        configurable: true,\r\n        writable: true,\r\n        // NOT enumerable when it's a bound method\r\n        enumerable: false,\r\n        value: boundFn,\r\n      })\r\n\r\n      return boundFn\r\n    },\r\n    set: createDefaultSetter(key),\r\n  }\r\n}\r\n\r\nfunction handle(args: any[]) {\r\n  if (args.length === 1) return autobindClass(args[0])\r\n  const [target, key, descriptor] = args\r\n  return autobindMethod(target, key, descriptor)\r\n}\r\n\r\nexport default function autobind(...args) {\r\n  if (args.length === 0) {\r\n    return function(...argsClass) {\r\n      return handle(argsClass)\r\n    }\r\n  }\r\n  return handle(args)\r\n}","import { decorate as _decorate, createDefaultSetter } from '../utils'\r\nconst { defineProperty } = Object\r\n\r\nexport function handleDescriptor(target, key, descriptor, [decorator, ...args]) {\r\n  if (descriptor === undefined)\r\n    descriptor = Object.getOwnPropertyDescriptor(target, key)\r\n\r\n  const { configurable, enumerable, writable } = descriptor\r\n  const originalGet = descriptor.get\r\n  const originalSet = descriptor.set\r\n  const originalValue = descriptor.value\r\n  const isGetter = !!originalGet\r\n\r\n  return {\r\n    configurable,\r\n    enumerable,\r\n    get() {\r\n      // 因為這邊以 getter 作為觸發\r\n      // 故原方法只要套用了一層 decorator 後面就都會拿到 isGetter: true\r\n      // 當 isGetter: true 時我們認定其為一個 decorator 進行取值\r\n      // 若 isGetter: false 時表示前面還沒套用任何 decorator，直接用原方法\r\n      // 將得到的 fn 丟進當前的 decorator 中執行得到最終的 value 方法\r\n      // 將 value 方法以 defineProperty 覆蓋回實例屬性的 descriptor\r\n      const fn = isGetter ? originalGet.call(this) : originalValue\r\n      const context = { target, key, fn }\r\n      const value = decorator.call(this, context, ...args)\r\n      const desc = {\r\n        configurable,\r\n        enumerable,\r\n        value,\r\n        writable,\r\n      }\r\n\r\n      // 這裡每個註冊的 decorator 只會各 set 1次\r\n      defineProperty(this, key, desc)\r\n\r\n      return value\r\n    },\r\n    set: isGetter ? originalSet : createDefaultSetter(key),\r\n  }\r\n}\r\n\r\nexport default function decorate(...args) {\r\n  return _decorate(handleDescriptor, args)\r\n}","/* eslint-disable no-console */\r\nimport { decorate } from '../utils'\r\nimport { handleDescriptor as handleDecorate } from './decorate'\r\n\r\n// Exported for mocking in tests\r\nconst labels = {}\r\n\r\nconst defaultConsole = {\r\n  time: console.time ? console.time.bind(console) : (label) => {\r\n    labels[label] = new Date()\r\n  },\r\n  timeEnd: console.timeEnd ? console.timeEnd.bind(console) : (label) => {\r\n    const timeNow: any = new Date()\r\n    const timeTaken = timeNow - labels[label]\r\n    delete labels[label]\r\n    console.log(`${label}: ${timeTaken}ms`)\r\n  },\r\n}\r\n\r\nfunction timeDecorator({ target, key, fn }, prefix = null, console = defaultConsole) {\r\n  let count = 0\r\n  if (prefix === null) prefix = `${target.constructor.name}.${key}`\r\n  return function(...args) {\r\n    const label = `${prefix}-${count}`\r\n    count++\r\n    console.time(label)\r\n    // support for async await\r\n    const p = Promise.resolve(fn.apply(this, args))\r\n    return p.then(() => console.timeEnd(label))\r\n  }\r\n}\r\n\r\n// 必須緊貼 async method，不然 async 會中斷\r\nexport default function time(...args) {\r\n  return decorate(handleDecorate, [timeDecorator, ...args])\r\n}","import { decorate } from '../utils'\r\n\r\nfunction handleDescriptor(target: any, key: PropertyKey, descriptor) {\r\n  descriptor.configurable = true\r\n  return descriptor\r\n}\r\n\r\nexport default function configurable(...args) {\r\n  return decorate(handleDescriptor, args)\r\n}","import { decorate } from '../utils'\r\n\r\nfunction handleDescriptor(target, key, descriptor) {\r\n  descriptor.enumerable = true\r\n  return descriptor\r\n}\r\n\r\nexport default function enumerable(...args) {\r\n  return decorate(handleDescriptor, args)\r\n}","import { decorate as _decorate } from '../utils'\r\nconst { getPrototypeOf, getOwnPropertyDescriptor } = Object\r\n\r\nfunction handleDescriptor(target, key, descriptor) {\r\n  const superKlass = getPrototypeOf(target)\r\n  const superDesc = getOwnPropertyDescriptor(superKlass, key)\r\n\r\n  const newDesc: any = {\r\n    configurable: superDesc.configurable || true,\r\n    enumerable: superDesc.enumerable || true,\r\n    initializer: descriptor.initializer,\r\n  }\r\n\r\n  if (descriptor.get || descriptor.set) {\r\n    newDesc.get = descriptor.get || superDesc.get\r\n    newDesc.set = descriptor.set || superDesc.set\r\n  } else {\r\n    newDesc.value = descriptor.value\r\n    newDesc.writable = superDesc.writable || true\r\n  }\r\n\r\n  return newDesc\r\n}\r\n\r\nexport default function extendDescriptor(...args) {\r\n  return _decorate(handleDescriptor, args)\r\n}","import { decorate, createDefaultSetter } from '../utils'\r\nconst { defineProperty } = Object\r\n\r\nfunction handleDescriptor(target, key, descriptor) {\r\n  const { configurable, enumerable, initializer, value } = descriptor\r\n  return {\r\n    configurable,\r\n    enumerable,\r\n    get() {\r\n      // This happens if someone accesses the\r\n      // property directly on the prototype\r\n      if (this === target) return\r\n\r\n      const ret = initializer ? initializer.call(this) : value\r\n\r\n      defineProperty(this, key, {\r\n        configurable,\r\n        enumerable,\r\n        writable: true,\r\n        value: ret,\r\n      })\r\n\r\n      return ret\r\n    },\r\n    set: createDefaultSetter(key),\r\n  }\r\n}\r\n\r\nexport default function lazyInit(...args) {\r\n  return decorate(handleDescriptor, args)\r\n}"],"mappings":"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","names":[]}